.section init
.temps r5, r6, r7

//---------------------------------------------------------------------------//
#									      #
#			Jump table initialization			      #
#									      #
//---------------------------------------------------------------------------//

jumptable:
	.space 256

table:
	r4 := jumptable
	table_loop:
		m[r0][r4] := input_error
		r4 := r4 + 1
		if(r4 != jumptable+255) goto table_loop

space_init:
	r4 := jumptable + ' '
	m[r0][r4] := waiting

operands_init:
	m[r0][jumptable + '*'] := multiply
	m[r0][jumptable + '+'] := add
	m[r0][jumptable + '-'] := subtract
	m[r0][jumptable + '/'] := divide
	m[r0][jumptable + '|'] := bitwise_or
	m[r0][jumptable + '&'] := bitwise_and
	m[r0][jumptable + 'c'] := negation
	m[r0][jumptable + '~'] := complement
	m[r0][jumptable + 's'] := swap
	m[r0][jumptable + 'd'] := duplicate
	m[r0][jumptable + 'p'] := pop_val
	m[r0][jumptable + 'z'] := pop_all

number_init:
	r4 := jumptable + '0'
	number_init_loop:
		m[r0][r4] := digit
		r4 := r4 + 1
		if(r4 != jumptable + ':') goto number_init_loop
	goto ustart

//---------------------------------------------------------------------------//
#									      #
#				Input handling				      #
#									      #
//---------------------------------------------------------------------------//

.section main
.temps r5, r6, r7
.zero r0

run:
	goto waiting

end:
	halt

waiting:
	r3 := input()

waiting_with_character:
	# -1 is EOF
	if(r3 == -1) goto end
	if(r3 == '\n') goto print_stack
	# goes to corresponding instruction in the jump table
	r4 := jumptable + r3
	r4 := m[r0][r4]
	goto r4

entering:
	r3 := input()
	if (r3 == '+') goto add
	if (r3 == '-') goto subtract
	if (r3 == '/') goto divide
	if (r3 == '*') goto multiply
	if (r3 == '|') goto bitwise_or
	if (r3 == 'c') goto negation
	if (r3 == 's') goto swap
	if (r3 == '~') goto complement
	if (r3 == 'd') goto duplicate
	if (r3 == 'p') goto pop_val
	if (r3 == 'z') goto pop_all
	if (r3 == '&') goto bitwise_and
	if (r3 == '0') goto multi_digit
	if (r3 == '1') goto multi_digit
	if (r3 == '2') goto multi_digit
	if (r3 == '3') goto multi_digit
	if (r3 == '4') goto multi_digit
	if (r3 == '5') goto multi_digit
	if (r3 == '6') goto multi_digit
	if (r3 == '7') goto multi_digit
	if (r3 == '8') goto multi_digit
	if (r3 == '9') goto multi_digit
	if (r3 <s '0') goto waiting_with_character	
	if (r3 >s '9') goto waiting_with_character
	goto entering
	
digit:
	r3 := r3 - '0'
	push r3 on stack r1
	goto entering

multi_digit:
	pop r4 off stack r1
	r3 := r3 - '0'
	r4 := r4 * 10
	r4 := r4 + r3
	push r4 on stack r1
	goto entering

input_error:
	output "Unknown character '"
	output r3
	output "'\n"
	goto waiting

//---------------------------------------------------------------------------//
#									      #
#		   Math functions and related error handling		      #
#									      #
//---------------------------------------------------------------------------//
#
#	Register use:
#		For the 'has' label, r4 holds the return value
#		For binary operators, r3 and r4 hold the operands
#		For unary operators, r3 holds the operand
#	
#
//---------------------------------------------------------------------------//



bad_operands_1:
	output "Stack underflow---expected at least 1 element\n"
	goto waiting

bad_operands_2:
	output "Stack underflow---expected at least 2 elements\n"
	goto waiting

//
// Counts the number of elements in the stack
//
has:
	push r3 on stack r2
	r4 := 0
	has_loop:
		r3 := valuestack - r4
		if(r3 == r1) goto return_has
		r4 := r4 + 1
		goto has_loop
	return_has:
		pop r3 off stack r2
		push r4 on stack r2 #return value
		goto r3
//
// Used by most the math functions as a general purpose way to return control
// to waiting
//
done_operation:
	push r3 on stack r1
	goto waiting

add:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 1) goto bad_operands_2
	pop r3 off stack r1
	pop r4 off stack r1
	r3 := r3 + r4
	goto done_operation

subtract:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 1) goto bad_operands_2
	pop r3 off stack r1
	pop r4 off stack r1
	r3 := r4 - r3
	goto done_operation

multiply:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 1) goto bad_operands_2
	pop r3 off stack r1
	pop r4 off stack r1
	r3 := r3 * r4
	goto done_operation
//
// Division is handled by the following 4 functions
//
divide:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 1) goto bad_operands_2
	pop r3 off stack r1
	pop r4 off stack r1
	if (r3 == 0) goto division_by_zero
	if (r4 <s 0) goto check_divisor
	if (r3 <s 0) goto signed_divide_one_neg
	goto unsigned_divide
	check_divisor:
		if (r3 <s 0) goto signed_divide_both_neg
		goto signed_divide_one_neg
	unsigned_divide:
	r3 := r4 / r3
	goto done_operation

division_by_zero:
	output "Division by zero\n"
	push r4 on stack r1
	push r3 on stack r1
	goto waiting

signed_divide_both_neg:
	if (r4 >s 0) goto done_flipping_both_neg_1
	r4 := r4 - 1
	r4 := r4 nand r4
	done_flipping_both_neg_1:
	if (r3 >s 0) goto done_flipping_both_neg_2
	r3 := r3 - 1
	r3 := r3 nand r3
	done_flipping_both_neg_2:
	r3 := r4 / r3
	goto done_operation


signed_divide_one_neg:
	if (r4 >s 0) goto done_flipping_one_neg_1
	r4 := r4 - 1
	r4 := r4 nand r4
	done_flipping_one_neg_1:
	if (r3 >s 0) goto done_flipping_one_neg_2
	r3 := r3 - 1
	r3 := r3 nand r3
	done_flipping_one_neg_2:
	r3 := r4 / r3
	r3 := r3 nand r3
	r3 := r3 + 1
	goto done_operation

bitwise_or:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 1) goto bad_operands_2
	pop r3 off stack r1
	pop r4 off stack r1
	r3 := r3 | r4
	goto done_operation

bitwise_and:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 1) goto bad_operands_2
	pop r3 off stack r1
	pop r4 off stack r1
	r3 := r3 & r4
	goto done_operation

negation:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 0) goto bad_operands_1
	pop r3 off stack r1
	r3 := r3 nand r3
	r3 := r3 + 1
	goto done_operation

complement:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 0) goto bad_operands_1
	pop r3 off stack r1
	r3 := r3 nand r3
	goto done_operation

swap:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 1) goto bad_operands_2
	pop r3 off stack r1
	pop r4 off stack r1
	push r3 on stack r1
	push r4 on stack r1
	goto waiting

duplicate:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 0) goto bad_operands_1
	pop r3 off stack r1
	r4 := r3
	push r4 on stack r1
	goto done_operation

pop_val:
	goto has linking r3
	pop r4 off stack r2
	if (r4 == 0) goto bad_operands_1
	pop stack r1
	goto waiting

pop_all:
	pop_loop:
	if (r1 == valuestack) goto waiting
	pop stack r1
	goto pop_loop